
#![allow(unused)]

/*
	
	1) ownership это концепция владения памятью, она важная и уникальная
	2) она позволяет обеспечивать безопасность памяти во время выполнения программы
	3) она позволяет обходится языку программирования без сборщика мусора
	4-1) ownership = каждый объект в памяти имеет одного владельца
	4-2) ownership = владелец полностью отвечает за свой объект
	4-3) ownership = если владелец "умирает" (выходит из области видимости), то его объекты тоже умирают
	4-4) ownership = владение можно передавать от 1-го хозяина 2-ому хозяину
	4-5) если переменная стала равна другой переменной
	4-6) если переменная передана в функцию как аргумент

*/

fn main() {

	let string1: String = String::from("Paris");
	let string2 = string1;
	println!("string2 = {}", string2);
	// println!("string1 = {}", string1);

	println!("====================");

	let string3: String = String::from("Tokio");
	let string4 = string3.clone();
	println!("string3 = {}", string3);
	println!("string4 = {}", string4);

	println!("====================");

	let a1: i32 = 10;
	let b1 = a1;
	println!("a1 = {}", a1);
	println!("b1 = {}", b1);

	// 5) примитивные типы поддерживают clone() автоматически
	// 6) нет необходимости писать clone() для чисел, символов и булевых значений
	// 7) строки и векторы имеют clone(), но автоматически не реализуются
	// 8) если мы хотим скопировать строку или вектор, то надо написать clone() 

}

/*

	9) есть три основные концепции языка Rust
	10-1) ownership (владение памятью): каждый объект имеет 1-го владельца
	10-2) borrowing (заимствование): вместо передачи в функцию переменной, мы передаем ссылку
	10-3) lifetime (жизненный цикл): у каждой ссылки есть время существования 


			fn main() {
			  let s = String::from("hello");
			  takes_ownership(s);
			  println!("{}", s);

			  let x = 5;
			  makes_copy(x);
			  println!("{}", x);
			}

			fn takes_ownership(some_string: String) {
			  println!("{}", some_string);
			}

			fn makes_copy(some_integer: i32) {
			  println!("{}", some_integer);
			}

			1) let s = String::from("hello"); => создаем строку
			2) takes_ownership(s);						=> вызывем функцию и даем ей строку
			3) строка `s` становится собственностью функции takes_ownership(), теперь она ее хозяйка
			4) строка `s` уходит из функции main(), она не является более хозяйкой этой строки
			5) функция takes_ownership() отрабатывает свой код: вывод строки на экран и конец функции
			6) println!("{}", s);							=> не будет выполнена, т.к. никакой строки `s` в main() нет
			7) let x = 5;											=> создаем целое число
			8) makes_copy(x);									=> вызываем функцию и даем ей КОПИЮ переменной
			9) функция makes_copy() отрабатывает сой код: вывод числа на экран и конец функции
			10) println!("{}", x);						=> код будет выполнен, т.к. переменная `x` не покидала main()

			11) какие типы автоматически копируются, т.е. остаются в основной программе при передаче в функцию
			12) какие типы автоматически копируются, т.е. реализуют трейт Copy
			13-1) i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, isize, usize, f32, f64, char, bool
			13-2) кортежи, состоящие только из типов данных, реализующих Copy
			13-3) структуры данных, состоящие только из типов данных, реализующих Copy 

			14) что такое трейт? (механизм, который позволяет определить поведение некоторых типов данных)

*/ 
