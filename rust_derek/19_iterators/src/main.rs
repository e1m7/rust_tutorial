
#![allow(unused)]

fn main() {

	// определим массив
	// определим массив
	// определим массив

	let mut array1 = [1,2,3,4,5,6,7,8];
	for arr in array1.iter() {
		println!("elem = {}", arr);
	}

	// итератор можно вызывать вне цикла, просто по мере надобности
	let mut my_iter_arr1 = array1.iter();
	println!("elem 0 = {:?}", my_iter_arr1.next());
	println!("elem 1 = {:?}", my_iter_arr1.next());

	/*
		1) как получить реальное значение массива через итератор, если он вызван через next()?
		2) допустим, мы хотим напечатать не Some(N), а само значение N из массива


				fn main() {
				    let result: Option<i32> = Some(42);

				    match result {
				        Some(value) => println!("Value: {}", value),
				        None => println!("No value"),
				    }
				}

	*/

	// итератор можно вызывать вне цикла, просто по мере надобности
	let mut my_iter_arr1 = array1.iter();
	println!("elem 0 = {:?}", my_iter_arr1.next().unwrap());
	println!("elem 1 = {:?}", my_iter_arr1.next().unwrap());


	// определим вектор
	// определим вектор
	// определим вектор

	let numbers1 = vec![10,20,30,40,50,60,70,80];
	let my_iter_num1 = numbers1.iter();

	for &number in my_iter_num1 {
		println!("vec = {}", number);
	}

	// задача: дан вектор, надо умножить все его элементы на 3 и выбрать только четные
	// задача: дан вектор, надо умножить все его элементы на 3 и выбрать только четные
	// задача: дан вектор, надо умножить все его элементы на 3 и выбрать только четные
	// [1,2,3,4,5] => [1,6,9,12,15] => [6,12]

	let numbers2 = vec![1,2,3,4,5];
	let result: Vec<i32> = numbers2.iter()
		.map(|&element| element * 3)
		.filter(|&element| element % 2 == 0)
		.collect();

	println!("result = {:?}", result);

}

/*

	3) итератор помогает перемещаться по массивам, векторам и картам
	4) значения, которые получает итератор, нельзя менять (они приходят как копии)
	5) итераторы работают как "ленивые вычисления", т.е. элемент вычисляется только когда он нужен
	6) итераторы можно комбинировать с тремя основными функциями: map, filter, fold (изучить сомостоятельно)
	7) итераторы работают с последовательностями безопасно, т.к. они сами проверяют их границы

*/
