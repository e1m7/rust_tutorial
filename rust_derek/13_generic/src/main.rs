
#![allow(unused)]

/*

	1) генерики = это механизм, который позволяет писать обобщенный код
	2) обобщенный код = работает с разными типами данных, не теряя безопастности
	3) генерики позволяют создавать функции, структуры, методы и конструкции для 1 или N типов
	4-1) плюс: можно один раз писать код, который работает с разными типами данных
	4-2) плюс: код гарантированно не будет ломаться, т.е. будет безопасность типов
	4-3) плюс: финальный код генерится специально для каждого типа и он будет эффективен
	

		// Функция, которая возвращает максимальное из двух значений
		// <T: Ord> это некий тип данных, который поддерживает трейт `Ord`
		fn max<T: Ord>(a: T, b: T) -> T {
		    if a > b {
		        a
		    } else {
		        b
		    }
		}

		fn main() {
		    let result = max(10, 5);
		    println!("Max: {}", result); // Выведет: Max: 10

		    let result = max("hello", "world");
		    println!("Max: {}", result); // Выведет: Max: world
		}

*/

// добавить функцию сложения из стандартной библиотеки
use std::ops::Add;

// первая попытка написать генерик для универсального сложения чисел
// fn generic_plus<T>(x: T, y: T) -> T {
// 	return x + y;
// }

// вторая попытка написать генерик для универсального сложения чисел
fn generic_plus<T: Add<Output = T>>(x: T, y: T) -> T {
	return x + y;
}


fn main() {

	// Задача: написать универсальную функцию, которая складывает числа разных типов (целое, дробное)
	// Решение 1: написать две разные функции с одним именем для разных типов, которые return a + b; (не сработает)
	// Решение 2: надо скорректировать саму функцию сложения, чтобы она работала с разными типами данных (сработает)

	println!("1 call generic_plus = {}", generic_plus(5, 6));
	println!("2 call generic_plus = {}", generic_plus(5.5, 6.1));
	// println!("3 call generic_plus = {}", generic_plus("hello".to_string(), "world".to_string()));

	// Вопрос на 1M$: почему этот генерик не даст сложить две строки?

}
