
#![allow(unused)]

fn main() {

	// создание векторов
	let vec1: Vec<i32> = Vec::new();
	let mut vec2 = vec![1, 2, 3, 4];

	// вывод вектора
	println!("vec1 = {:?}", vec1);
	println!("vec2 = {:?}", vec2);

	// добавление элементов (в конец)
	vec2.push(100);
	vec2.push(200);
	println!("vec2 = {:?}", vec2);

	// вывод отдельного элемента вектора
	println!("vec2[1] = {}", vec2[1]);
	println!("vec2[5] = {}", vec2[5]);

	// удаление элементов (с конца)
	vec2.pop();
	vec2.pop();

	println!("vec2 = {:?}", vec2);

	println!("================================");

	// начались сложности...
	// начались сложности...
	// начались сложности...

	// создание переменной = элементу вектора

	let mut vec3 = vec![1, 2, 3, 4];			// 1) создаем изменяемый вектор vec3 = [1,2,3,4] 
	let val: i32 = vec3[1];								// 2) создаем переменную val = vec3[1] = 2 
	println!("val = {}", val);						// 3) выводим ее значение на экран (2) 
	vec3[1] = 999;												// 4) меняем значение 1-го элемента вектора (2 => 999) 
	println!("vec3[1] = {}", vec3[1]);		// 5) выводим значение 1-го элемента вектора (999) 
	println!("val = {}", val);						// 6) выводим значение переменной val (2) 

	println!("================================");	

	// как умножить все значения вектора на два?

	let mut vec4 = vec![0,4,5,6];
	println!("vec4 = {:?}", vec4);
	for el in &mut vec4 { *el = *el * 2; }
	println!("vec4 = {:?}", vec4);

}

/*

	1) вектор может хранить значения элементов одного типа
	2) в чем разница между массивами и векторами?

	2-1) у массива фиксированный размер (задается при создании)
	2-2) у вектора динамический размер (можно удалять, прибавлять элементы)
	3-1) для массива память выделяется в стеке (конкретное число = числу элементов)
	3-2) для вектора память выделяется в куче (бесконечное число памяти = свободная зона) 
	4-1) массивы используют когда структура данных известна и четко определена
	4-2) векторы используют когда структура данных неизвестна или меняется со временем  

	5) переменная val не получит власти над 1-ым элементов вектора
	6) если 1-ый элемент изменится, то он не тронет val				// val надо будет сделать mut
	7) если val изменится, то он не тронет 1-ый элемент 			// val надо будет сделать mut
	8) возможно сделать так, чтобы связать val и элемент 1-ый так, чтобы их изменения меняли друг друга

	9) * = это разыменование ссылки, т.е. это процесс получения значения, которое лежит по адресу (ссылке)


*/
