
#![allow(unused)]
use std::cmp::Ordering;

fn main() {

	let age: u32 = 30;

	if (age >= 18) {
		println!("Вы должны работать!");
	} else {
		println!("Вы не должны работать!");
	}

	if (age < 18) {
		println!("Вы еще маленький");
	} else if (age < 65) {
		println!("Вы должны работать!");
	} else {
		println!("Вы должны быть на пенсии!");
	}

	let mut sample = 25;
	let man_vote: bool = if (sample >= 18) { true } else { false };		// замечание про ;
	println!("Vote for age {} is = {}", sample, man_vote);

	let woman_age: u32 = 0;
	match woman_age {
		1..=10 => println!("Девочка"),
		11..=20 => println!("Девушка"),
		21..=30 => println!("Женщина"),
		31..=40 => println!("Мать"),
		41..=u32::MAX => println!("Бабушка"),
		_ => println!("Мы не знаем кто вы такая")
	}

	let my_age: i32 = 28;
	let vote_age: i32 = 18;
	match my_age.cmp(&vote_age) {
		Ordering::Less => println!("Вам еще рано голосовать"),
		Ordering::Greater => println!("Вам уже поздно голосовать"),
		Ordering::Equal => println!("Вам самое время голосовать"),
	};

}

/*

	1) выражения внутри фигурных скобок должны быть без ; на конце true | false
	2) "true; | false;" это оператор, который выполняется и не возвращает значения
	3) вернее, он возвращает пустое значение = (), которое по типу != bool
	4) в некоторых языках оператор присваивания возвращает свой результат (a = 10 ==> 10)
	5) в некоторых языках можно писать: let a = let b = 10 + 2; (a=() <== ошибка!!!, b=12)

	6) для сравнения двух чисел (типов, которые поддерживают сравнение) есть библиотека Ordering
	7) она работет с связке с match: что-сравниваем.cmp(с-чем-сравниваем)
	8) мнемоническое правило: a.cmp(b) === a ? b
	9-1) a < b => Less (меньше)
	9-2) a > b => Greater (больше)
	9-3) a = b => Equal (равно)
	10) второе число передается в функцию сравнение cmp() по ссылке
	11) второе число не может уйти из-за потери владения (немного рассказать про владение)

*/
